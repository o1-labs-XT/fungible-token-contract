import {
  Field,
  ZkProgram,
  Struct,
  Bool,
  Bytes,
  Hash,
  SmartContract,
  method,
  Permissions,
  DeployArgs,
  Crypto,
  createForeignCurve,
  createEcdsa,
  PublicKey,
  State,
  state,
  UInt64,
  VerificationKey,
} from 'o1js';
import { FungibleToken, VKeyMerkleMap } from '../NewTokenStandard.js';
import { SideloadedProof } from '../side-loaded/program.eg.js';

// === ECDSA ZkProgram Definition ===

export class Secp256k1 extends createForeignCurve(
  Crypto.CurveParams.Secp256k1
) {}
export class Ecdsa extends createEcdsa(Secp256k1) {}

// === Combined ECDSA and Keccak ZkProgram Definition ===
/**
 * Public input for the combined ECDSA and Keccak verification ZkProgram.
 */
export class EcdsaAndKeccakProgramPublicInput extends Struct({
  // ECDSA part
  signature: Ecdsa,
  publicKey: Secp256k1,
  message: Bytes(32),
  // Keccak part
  expectedKeccakHash: Bytes(32),
}) {}

/**
 * Public output for the combined verification ZkProgram.
 */
export class EcdsaAndKeccakProgramPublicOutput extends Struct({
  isValid: Bool,
}) {}

export const EcdsaAndKeccakProgram = ZkProgram({
  name: 'ecdsa-keccak-verification',
  publicInput: EcdsaAndKeccakProgramPublicInput,
  publicOutput: EcdsaAndKeccakProgramPublicOutput,

  methods: {
    verifyEcdsaAndKeccak: {
      privateInputs: [Bytes(32)],
      async method(
        publicInput: EcdsaAndKeccakProgramPublicInput,
        keccakPreimage: Bytes
      ) {
        // 1. ECDSA Verification
        const isEcdsaSignatureValid = publicInput.signature.verify(
          publicInput.message,
          publicInput.publicKey
        );

        // 2. Keccak Verification
        const computedKeccakHash = Hash.Keccak256.hash(keccakPreimage);
        for (let i = 0; i < 32; i++) {
          const expectedByte = publicInput.expectedKeccakHash.bytes[i];
          const computedByte = computedKeccakHash.bytes[i];
          expectedByte.assertEquals(
            computedByte,
            `Keccak byte mismatch at index ${i}`
          );
        }

        return {
          publicOutput: new EcdsaAndKeccakProgramPublicOutput({
            isValid: isEcdsaSignatureValid,
          }),
        };
      },
    },
  },
});

export class EcdsaAndKeccakProof extends ZkProgram.Proof(
  EcdsaAndKeccakProgram
) {}

// === Token Proof Verifier SmartContract Definition ===

/**
 * A SmartContract that verifies baked-in proofs (e.g., ECDSA, Keccak)
 * as a condition for authorizing actions on an associated FungibleToken contract.
 */
export class TokenManager extends SmartContract {
  @state(PublicKey) tokenAddress = State<PublicKey>();

  async deploy(args: DeployArgs & { tokenAddress: PublicKey }) {
    await super.deploy(args);
    this.account.permissions.set({
      ...Permissions.default(),
      send: Permissions.proof(),
      setVerificationKey:
        Permissions.VerificationKey.impossibleDuringCurrentVersion(),
      setPermissions: Permissions.impossible(),
    });
    this.tokenAddress.set(args.tokenAddress);
  }

  /**
   * Verifies required cryptographic proofs (ECDSA, Keccak) and, if valid,
   * executes an action on the token contract.
   * @param ecdsaProof A proof generated by EcdsaProgram.verifySignature.
   * @param keccakProof A proof generated by KeccakProgram.verifyPreimage.
   */
  @method
  async withdrawTokens(
    amount: UInt64,
    combinedProof: EcdsaAndKeccakProof,
    ftProof: SideloadedProof,
    vk: VerificationKey,
    vKeyMap: VKeyMerkleMap
  ) {
    combinedProof.verify();
    combinedProof.publicOutput.isValid.assertTrue(
      'ECDSA and Keccak verification failed'
    );

    ftProof.verify(vk);

    const token = new FungibleToken(this.tokenAddress.getAndRequireEquals());
    const sender = this.sender.getUnconstrained();

    await token.transferCustom(
      this.address,
      sender,
      amount,
      ftProof,
      vk,
      vKeyMap
    );
  }
}
